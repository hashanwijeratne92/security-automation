name: Trivy Image Scan
on:
  workflow_dispatch:
    inputs:
      images:
        description: 'JSON array of images'
        required: true
        type: string
      callback:
        description: 'n8n webhook URL (will receive scan results)'
        required: true
        type: string
      token:
        description: 'shared secret (echoed as X-Scanner-Token)'
        required: false
        type: string
      corr:
        description: 'correlation id (optional)'
        required: false
        type: string

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@v0.2.3

      # ===== OPTIONAL: login to private registries (uncomment the one you need) =====
      # - name: Docker login (Nexus / generic registry)
      #   if: ${{ env.NEXUS_USER != '' }}
      #   env:
      #     NEXUS_USER: ${{ secrets.NEXUS_USER }}
      #     NEXUS_PASS: ${{ secrets.NEXUS_PASS }}
      #     NEXUS_REG:  ${{ secrets.NEXUS_REG }}
      #   run: echo "$NEXUS_PASS" | docker login "$NEXUS_REG" -u "$NEXUS_USER" --password-stdin

      # - name: Azure Container Registry login
      #   env:
      #     ACR_NAME: ${{ secrets.ACR_NAME }}
      #     ACR_USER: ${{ secrets.ACR_USER }}
      #     ACR_PASS: ${{ secrets.ACR_PASS }}
      #   run: echo "$ACR_PASS" | docker login "$ACR_NAME.azurecr.io" -u "$ACR_USER" --password-stdin

      # - name: AWS ECR login
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     aws-region: ${{ secrets.AWS_REGION }}
      # - name: ECR login
      #   run: aws ecr get-login-password | docker login --username AWS --password-stdin ${{ secrets.AWS_ECR_REGISTRY }}

      - name: Scan images (Trivy)
        id: scan
        env:
          IMAGES: ${{ github.event.inputs.images }}
        run: |
          set -e
          results='{"results":[],"corr":"${{ github.event.inputs.corr }}"}'
          tmp=$(mktemp)
          echo "$IMAGES" | jq -c '.[]' | while read -r img; do
            I=$(echo "$img" | tr -d '"')
            echo "Scanning $I..."
            # Trivy returns exit 1 when vulns are found; we still want JSON
            trivy image --format json --severity HIGH,CRITICAL "$I" > "$tmp" || true

            jq --arg image "$I" '
              {
                image: $image,
                ok: true,
                highCritCount: ([.Results[].Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length),
                fixableCount: ([.Results[].Vulnerabilities[]? | select((.Severity=="HIGH" or .Severity=="CRITICAL") and (.FixedVersion != null and .FixedVersion != ""))] | length),
                rows: ([.Results[].Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL") | {
                  id: .VulnerabilityID, pkg: .PkgName, installed: .InstalledVersion,
                  fixed: (.FixedVersion // ""), severity: .Severity, title: (.Title // ""),
                  url: (.PrimaryURL // ( .References[0] // "" ))
                }]),
                raw: .
              }
            ' "$tmp" > "$tmp.out"

            results=$(jq --slurpfile r "$tmp.out" '.results += $r' <<< "$results")
          done
          echo "payload=$results" >> $GITHUB_OUTPUT

      - name: POST results to n8n Webhook
        env:
          CB: ${{ github.event.inputs.callback }}
          TOK: ${{ github.event.inputs.token }}
          PAYLOAD: ${{ steps.scan.outputs.payload }}
        run: |          
          hdr=(-H 'Content-Type: application/json')
          if [ -n "$TOK" ]; then
            hdr+=(-H "X-Scanner-Token: $TOK")
          fi
          curl -sS -X POST "${hdr[@]}" -d "$PAYLOAD" "$CB"
           
