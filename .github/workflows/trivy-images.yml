name: Trivy Image Scan
on:
  workflow_dispatch:
    inputs:
      images:
        description: 'JSON array of images'
        required: true
        type: string
      callback:
        description: 'n8n webhook URL (will receive scan results)'
        required: true
        type: string
      token:
        description: 'shared secret (echoed as X-Scanner-Token)'
        required: false
        type: string
      corr:
        description: 'correlation id (optional)'
        required: false
        type: string

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@v0.2.3

      # --- Login steps remain unchanged ---

      - name: Scan images (Trivy)
        id: scan
        env:
          IMAGES: ${{ github.event.inputs.images }}
        run: |
          # We initialize the final result JSON.
          results='{"results":[],"corr":"${{ github.event.inputs.corr }}"}'
          tmp=$(mktemp)
          
          # CRITICAL FIX 1: Use process substitution (< <(...)) to avoid subshell issues 
          while read -r img; do
            I=$(echo "$img" | tr -d '"')
            echo "Scanning $I..."
            
            # Trivy returns exit 1 when vulns are found; we still want JSON
            trivy image --format json --severity HIGH,CRITICAL "$I" > "$tmp" || true

            # Process Trivy JSON with jq
            jq --arg image "$I" '
              {
                image: $image,
                ok: true,
                highCritCount: ([.Results[].Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL")] | length),
                fixableCount: ([.Results[].Vulnerabilities[]? | select((.Severity=="HIGH" or .Severity=="CRITICAL") and (.FixedVersion != null and .FixedVersion != ""))] | length),
                rows: ([.Results[].Vulnerabilities[]? | select(.Severity=="HIGH" or .Severity=="CRITICAL") | {
                  id: .VulnerabilityID, pkg: .PkgName, installed: .InstalledVersion,
                  fixed: (.FixedVersion // ""), severity: .Severity, title: (.Title // ""),
                  url: (.PrimaryURL // ( .References[0] // "" ))
                }]),
                raw: .
              }
            ' "$tmp" > "$tmp.out"

            # Aggregate the results
            results=$(jq --slurpfile r "$tmp.out" '.results += $r' <<< "$results")
          done < <(echo "$IMAGES" | jq -c '.[]')
          
          # Save the final JSON to a file
          echo "$results" > final_payload.json

          # DEBUG: Print the final payload to the action log for verification
          echo "--- START: Final Aggregated JSON Payload ---"
          echo "$results"
          echo "--- END: Final Aggregated JSON Payload ---"

      - name: POST results to n8n Webhook
        # Removed the PAYLOAD environment variable as it's no longer needed
        env:
          CB: ${{ github.event.inputs.callback }}
          TOK: ${{ github.event.inputs.token }}
        run: |
          hdr=(-H 'Content-Type: application/json')
          if [ -n "$TOK" ]; then
            hdr+=(-H "X-Scanner-Token: $TOK")
          fi
          # FINAL FIX: Read the payload directly from the file to bypass size limits
          curl -sS -X POST "${hdr[@]}" --data-binary @final_payload.json "$CB"
